# Script-level comment:
# This script, Ex4_TL_inversion.py, demonstrates various advanced time-lapse
# Electrical Resistivity Tomography (ERT) inversion techniques available in PyHydroGeophysX.
# It builds upon synthetic ERT data, potentially generated by a script like Ex3.
#
# Key techniques showcased:
# 1. Full L2 Time-Lapse Inversion:
#    - Inverts all time-lapse datasets simultaneously.
#    - Employs temporal regularization (controlled by `alpha`) to ensure smooth
#      transitions and consistency between resistivity models of consecutive timesteps.
#    - Uses L2 norm for both data misfit and model regularization (spatial and temporal).
# 2. Windowed L2 Time-Lapse Inversion:
#    - Designed for handling large time-lapse datasets where inverting all timesteps
#      at once might be computationally prohibitive.
#    - Processes data in overlapping moving windows (e.g., 3 timesteps per window).
#    - Temporal regularization is applied within each window.
# 3. Full L1 Time-Lapse Inversion:
#    - Similar to the full L2 inversion but uses L1 norm for model regularization.
#    - L1 norm tends to produce models with sharper boundaries and blocky features,
#      which can be more geologically realistic in some scenarios.
#
# For each inversion type, the script:
# - Defines paths to the time-lapse ERT data files.
# - Sets up measurement times (can be indices or actual timestamps).
# - Creates or loads an inversion mesh.
# - Specifies various inversion parameters (regularization strength `lambda_val`,
#   temporal coupling `alpha`, solver method, error models, iteration limits, etc.).
# - Instantiates the appropriate inversion class (`TimeLapseERTInversion` or `WindowedTimeLapseERTInversion`).
# - Runs the inversion.
# - Visualizes the resulting time-lapse resistivity models.
#
# Assumptions:
# - Synthetic time-lapse ERT data files (e.g., "synthetic_data30.dat", "synthetic_data60.dat", etc.)
#   are available in the directory specified by `data_dir`. This directory path is hardcoded
#   and likely needs adjustment by the user. These files would typically be outputs from a
#   script like `Ex3_Time_lapse_measurement.py`.
# - The data files are in a format readable by PyGIMLi/ERTManager (e.g., .dat).
#
# Expected output:
# - Console output: Progress messages during the inversion processes.
# - Matplotlib plots: For each inversion technique, a figure showing the inverted
#   resistivity models for all 12 timesteps, allowing visual comparison of the
#   subsurface evolution and the performance of different inversion strategies.
# - Saved files: This script primarily focuses on demonstrating inversion and plotting;
#   explicit file saving of inversion results (models, data responses) is not shown
#   but could be added by uncommenting or extending relevant sections.

"""
Ex 4. Time-Lapse ERT Inversion Techniques
===================================

This example demonstrates different approaches for time-lapse electrical 
resistivity tomography (ERT) inversion using PyHydroGeophysX.

The example includes:
1. Full time-lapse inversion with temporal regularization
2. Windowed time-lapse inversion for large datasets
3. L1-norm regularized inversion for sharp boundary recovery
4. Comparison of different inversion strategies
5. Visualization of resistivity evolution over time

Time-lapse ERT inversion is crucial for monitoring subsurface water 
content changes and understanding hydrological processes in watersheds.
The temporal regularization helps maintain consistency between consecutive
time steps while allowing for realistic changes.
"""
# --- Standard library and third-party imports ---
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
import pygimli as pg # PyGIMLi for geophysical modeling, mesh handling, and ERT.
from pygimli.physics import ert # Specifically for ERT related tasks.
from mpl_toolkits.axes_grid1 import make_axes_locatable # For advanced colorbar placement.

# --- Setup package path for development ---
# Ensures the script can find PyHydroGeophysX when run directly from the examples folder.
try:
    # For regular Python scripts where __file__ is defined.
    current_dir = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback for interactive environments like Jupyter notebooks.
    current_dir = os.getcwd()

# Add the parent directory (project root) to the Python path.
parent_dir = os.path.dirname(current_dir) # Navigate one level up.
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

# --- Import PyHydroGeophysX specific modules ---
# Import classes for time-lapse ERT inversion.
from PyHydroGeophysX.inversion.time_lapse import TimeLapseERTInversion
from PyHydroGeophysX.inversion.windowed import WindowedTimeLapseERTInversion

# %%
# --- Define Path to Time-Lapse ERT Data ---
# `data_dir` should point to the directory containing the sequence of ERT data files.
# IMPORTANT: This is a hardcoded absolute path. Users must change this to their data location.
# These data files are expected to be outputs from Ex3 (synthetic ERT data for different timesteps).
# SUGGESTION: Use a relative path, e.g., os.path.join(os.path.dirname(current_dir), "results", "Ex3_TL_measurements_results", "appres")
data_dir = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples/results/TL_measurements/appres"

# List of ERT data filenames, representing a sequence of measurements over time.
# This example assumes monthly data over a year (12 files).
# These filenames correspond to those saved in Ex3.
ert_files = [
    "synthetic_data30.dat",  # Data for day 30
    "synthetic_data60.dat",  # Data for day 60
    "synthetic_data90.dat",  # ... and so on
    "synthetic_data120.dat",
    "synthetic_data150.dat",
    "synthetic_data180.dat",
    "synthetic_data210.dat",
    "synthetic_data240.dat",
    "synthetic_data270.dat",
    "synthetic_data300.dat",
    "synthetic_data330.dat",
    "synthetic_data360.dat",
]


# %% [markdown]
# ## 1.Full L2 Time-Lapse Inversion
# <!-- This section demonstrates a full time-lapse inversion where all datasets are inverted simultaneously -->
# <!-- with temporal (L2-norm) regularization coupling consecutive time steps. -->

# %%
##################### FUll Time-Lapse Inversion #####################
# This approach inverts all time steps together, enforcing smoothness both spatially
# and temporally (between consecutive time steps).

# Construct full paths to the ERT data files.
data_files = [os.path.join(data_dir, f) for f in ert_files]

# Define measurement times. These can be simple indices (1, 2, 3, ...),
# actual dates, or elapsed time in consistent units. They are used for temporal regularization.
# Here, they represent nominal months or measurement campaigns.
measurement_times = [1, 2, 3, 4, 5, 6, 7 ,8, 9, 10, 11, 12]

# Create or load an inversion mesh.
# For consistency, the mesh is typically created based on the first dataset's sensor locations.
# It's assumed all datasets in the time-lapse sequence use the same survey geometry.
data = ert.load(data_files[0]) # Load the first ERT data file to get geometry.
ert_manager = ert.ERTManager(data) # Use ERTManager to help create a suitable mesh.
# `quality=34` is a PyGIMLi mesh quality parameter (minimum triangle angle).
mesh = ert_manager.createMesh(data=data, quality=34)

# Set up inversion parameters for the time-lapse inversion.
inversion_params = {
    "lambda_val": 50.0,              # Spatial regularization strength (smoothness).
    "alpha": 10.0,                   # Temporal regularization strength (coupling between time steps).
    "decay_rate": 0.0,               # Decay rate for temporal regularization (0.0 means constant coupling).
    "method": "cgls",                # Solver method for the linear system (e.g., 'cgls', 'lsqr').
    "model_constraints": (0.001, 1e4), # Minimum and maximum allowed resistivity values (Ohm-m).
    "max_iterations": 15,            # Maximum number of Gauss-Newton iterations.
    "absoluteUError": 0.0,           # Absolute data error component (e.g., in Volts or Ohm-m).
    "relativeError": 0.05,           # Relative data error component (e.g., 5% = 0.05).
    "lambda_rate": 1.0,              # Factor to reduce lambda_val per iteration (1.0 = no reduction).
    "lambda_min": 1.0,               # Minimum lambda_val if reduction is applied.
    "inversion_type": "L2"           # Type of norm for model regularization ('L1', 'L2', or 'L1L2'). L2 promotes smooth models.
}

# Create the TimeLapseERTInversion object.
# This object manages the setup and execution of the full time-lapse inversion.
inversion_full_l2 = TimeLapseERTInversion( # Renamed for clarity
    data_files=data_files,             # List of paths to ERT data files.
    measurement_times=measurement_times, # List/array of measurement times.
    mesh=mesh,                         # The inversion mesh.
    **inversion_params                 # Pass other inversion parameters as keyword arguments.
)

# Run the time-lapse inversion.
print("Starting full L2 time-lapse inversion...")
result_full_l2 = inversion_full_l2.run() # Renamed result variable
print("Full L2 time-lapse inversion complete!")

# %%
# --- Visualize Results of Full L2 Time-Lapse Inversion ---
# Plot the inverted resistivity models for each of the 12 timesteps.
from palettable.lightbartlein.diverging import BlueDarkRed18_18 # Import a colormap.
fixed_cmap = BlueDarkRed18_18.mpl_colormap # Assign colormap.

# Create a figure to display all 12 resistivity models.
fig_full_l2, axes_full_l2 = plt.subplots(3, 4, figsize=[16,6]) # 3 rows, 4 columns for 12 plots. Renamed.
axes_full_l2 = axes_full_l2.flatten() # Flatten the 2D array of axes for easy iteration.

# Loop through each timestep and plot its corresponding inverted resistivity model.
for i in range(12): # Assuming 12 timesteps.
    ax = axes_full_l2[i]
    # `result_full_l2.mesh` is the inversion mesh.
    # `result_full_l2.final_models[:,i]` is the resistivity model for the i-th timestep.
    # `coverage=result_full_l2.all_coverage[i]>-1` masks cells with low coverage (poorly resolved).
    # `cMin`, `cMax` define the color scale limits for consistent plotting.
    _, cbar = pg.show(result_full_l2.mesh, result_full_l2.final_models[:,i], pad=0.3, orientation="vertical",
                      cMap=fixed_cmap, cMin=100, cMax=3000, logScale=False,
                      ylabel="Elevation (m)", label='Resistivity ($\Omega$m)', ax=ax,
                      coverage=(result_full_l2.all_coverage[i] > -1 if result_full_l2.all_coverage is not None else None))
    cbar.remove() # Remove individual colorbars; a single one might be added later if desired.
    ax.set_title(f"L2 - Timestep {measurement_times[i]}") # Add title with measurement time.

fig_full_l2.tight_layout() # Adjust layout.
plt.suptitle("Full L2 Time-Lapse Inversion Results", fontsize=16, y=1.02) # Overall title.
plt.show() # Display the plot. Expected output: A figure with 12 subplots.

# %% [markdown]
# ## 2. Window L2 time-lapse inversion
# <!-- This section demonstrates windowed time-lapse inversion. This approach processes -->
# <!-- a subset (window) of consecutive timesteps at a time, making it suitable for very large time-series datasets. -->
# <!-- L2 norm is used for regularization. -->

# %%
# --- Setup for Windowed L2 Time-Lapse Inversion ---
# Measurement times and mesh are typically reused from the full inversion setup, or re-defined if different.
# `measurement_times` and `mesh` from the previous section are assumed to be available here.

# Define inversion parameters, potentially adjusted for windowed approach if needed.
# Here, `lambda_val` is reduced compared to the full inversion example.
inversion_params_windowed_l2 = { # Renamed for clarity
    "lambda_val": 10.0, # Regularization parameter for each window.
    "alpha": 10.0,      # Temporal regularization within the window.
    "decay_rate": 0.0,
    "method": "cgls",
    "model_constraints": (0.001, 1e4),
    "max_iterations": 15,
    "absoluteUError": 0.0,
    "relativeError": 0.05,
    "lambda_rate": 1.0,
    "lambda_min": 1.0,
    "inversion_type": "L2"
}

# Define the window size: number of timesteps to be processed together in each sliding window.
# A window size of 3 means each inversion processes 3 consecutive measurements.
window_size = 3

# Create the WindowedTimeLapseERTInversion object.
# This object manages the setup and execution of the windowed inversion.
inversion_windowed_l2 = WindowedTimeLapseERTInversion( # Renamed for clarity
    data_dir=data_dir,               # Directory containing all ERT data files.
    ert_files=ert_files,             # List of ERT data filenames in temporal order.
    measurement_times=measurement_times,  # List of measurement times/indices.
    window_size=window_size,         # Number of timesteps in each processing window.
    mesh=mesh,                       # The inversion mesh (same for all windows).
    **inversion_params_windowed_l2   # Pass other inversion parameters.
)

# Run the windowed time-lapse inversion.
# The `run` method will iterate through the windows, performing inversion for each.
print("Starting windowed L2 time-lapse inversion...")
result_windowed_l2 = inversion_windowed_l2.run() # Renamed result variable
print("Windowed L2 time-lapse inversion complete!")


# %%
# Ensure the final models from windowed inversion are in a NumPy array for consistent processing/plotting.
# The WindowedTimeLapseERTInversion might return a list of models if processed independently.
result_windowed_l2.final_models = np.array(result_windowed_l2.final_models)
# Print the shape to confirm: (number_of_mesh_cells, number_of_timesteps).
print(f"Shape of windowed L2 final models: {result_windowed_l2.final_models.shape}")


# %%
# --- Visualization of Windowed L2 Time-Lapse Inversion Results ---
# This section plots the inverted resistivity models obtained from the windowed approach.
# Import necessary libraries (already imported, but good practice if cell is run standalone).
from palettable.lightbartlein.diverging import BlueDarkRed18_18
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pylab as pylab

# Define Matplotlib styling parameters for the plot.
params_windowed_plot = {'legend.fontsize': 13, # Renamed params dict
                        'axes.labelsize': 13,
                        'axes.titlesize':13,
                        'xtick.labelsize':13,
                        'ytick.labelsize':13}
pylab.rcParams.update(params_windowed_plot)
plt.rcParams["font.family"] = "Arial"

# Assign colormap.
fixed_cmap_windowed = BlueDarkRed18_18.mpl_colormap # Renamed for clarity

# Create a figure to display all 12 resistivity models from the windowed inversion.
fig_windowed_l2, axes_windowed_l2 = plt.figure(figsize=[16, 6]), [] # Create figure, axes will be added in loop. Renamed.
# Use `subplots_adjust` for finer control over spacing if needed, or rely on `tight_layout` later.
# plt.subplots_adjust(wspace=0.05, hspace=0.05) # Example adjustment

# Iterate through each timestep and plot its corresponding inverted resistivity model.
for i in range(12): # Assuming 12 timesteps.
    row, col = i // 4, i % 4 # Calculate subplot row and column.
    ax = fig_windowed_l2.add_subplot(3, 4, i + 1) # Add subplot to the figure.
    axes_windowed_l2.append(ax) # Store axis if needed later, though not used in this loop structure.
    
    # Determine if Y-axis label ("Elevation (m)") should be shown (only for leftmost subplots).
    ylabel_text = "Elevation (m)" if col == 0 else None
    
    # Determine if the colorbar label should be shown (e.g., only for one specific subplot to avoid repetition).
    # Here, it's shown for the 8th plot (index 7), which is middle row, rightmost plot.
    resistivity_cbar_label = 'Resistivity ($\Omega$m)' if (i == 7) else None # Corrected label text.
    
    # Control visibility of X and Y ticks for a cleaner grid display.
    if col != 0: # If not the first column, hide Y-ticks.
        ax.set_yticks([])
    if row != 2:  # If not the bottom row, hide X-ticks.
        ax.set_xticks([])
    else: # For bottom row, set X-axis label.
        ax.set_xlabel("Distance (m)")
    
    # Plot the resistivity model for the current timestep `i`.
    # `result_windowed_l2.mesh` is the mesh.
    # `result_windowed_l2.final_models[:,i]` is the model for this timestep.
    # `result_windowed_l2.all_coverage[i]` is used for masking.
    _, cbar = pg.show(result_windowed_l2.mesh,
                      result_windowed_l2.final_models[:,i],
                      pad=0.3, orientation="vertical",
                      cMap=fixed_cmap_windowed, cMin=100, cMax=3000, logScale=False,
                      ylabel=ylabel_text, label=resistivity_cbar_label, ax=ax,
                      coverage=(result_windowed_l2.all_coverage[i] > -1.2 if result_windowed_l2.all_coverage is not None and i < len(result_windowed_l2.all_coverage) else None))
                      # Added checks for all_coverage existence and length. Original code might error if coverage is not computed for all steps.
    
    # Remove individual colorbars from subplots where the label is not shown.
    if i != 7:
        if cbar: cbar.remove() # Check if cbar exists before removing.
    ax.set_title(f"WinL2 - T{measurement_times[i]}") # Add title with measurement time.


fig_windowed_l2.tight_layout() # Adjust overall layout.
plt.suptitle("Windowed L2 Time-Lapse Inversion Results", fontsize=16, y=1.02) # Overall title for the figure.
plt.show() # Display the plot.


# %% [markdown]
# ## 3. Full L1 Time-lapse Inversion
# <!-- This section demonstrates a full time-lapse inversion similar to section 1, -->
# <!-- but uses L1 norm for model regularization. L1 norm tends to produce blockier models -->
# <!-- with sharper boundaries, which can be beneficial for certain geological settings. -->

# %%
# This cell in the original script seems to be an unintentional repeat of a plotting command from section 1
# or a placeholder. It plots the last `i` from the previous loop using `result.final_models`
# which refers to `result_windowed_l2` in this context if run sequentially.
# For clarity, this should either be removed or corrected to plot a specific L1 result later.
# ax, cbar = pg.show(result.mesh,result.final_models[:,i],pad=0.3,orientation="vertical",cMap=fixed_cmap,cMin= 100,cMax = 3000
#                     , ylabel="Elevation (m)",label=' Resistivity ($\Omega$ m)',logScale=False,coverage=result.all_coverage[i]>-1)
# Commenting this out as it's likely a leftover or misplaced cell.

# %%
# This cell is empty in the original script.

# %%
# --- Setup for Full L1 Time-Lapse Inversion ---
# The data files, measurement times, and mesh are typically the same as for the L2 full time-lapse inversion.
# `data_files`, `measurement_times`, and `mesh` variables are reused from the L2 setup (section 1).

# Set up inversion parameters, with the key difference being `inversion_type": "L1"`.
# Other parameters like lambda might also be tuned differently for L1 vs L2.
inversion_params_l1 = { # Renamed for clarity
    "lambda_val": 50.0,      # Regularization strength.
    "alpha": 10.0,           # Temporal regularization strength.
    "decay_rate": 0.0,
    "method": "cgls",        # Solver. Note: L1 often involves iterative reweighting not directly part of CGLS.
                             # The TimeLapseERTInversion class handles the IRLS (Iteratively Reweighted Least Squares) for L1.
    "model_constraints": (0.001, 1e4),
    "max_iterations": 15,
    "absoluteUError": 0.0,
    "relativeError": 0.05,
    "lambda_rate": 1.0,
    "lambda_min": 1.0,
    "inversion_type": "L1"   # Specify L1 norm for model regularization.
}

# Create the TimeLapseERTInversion object for L1 inversion.
inversion_full_l1 = TimeLapseERTInversion( # Renamed
    data_files=data_files,
    measurement_times=measurement_times,
    mesh=mesh, # Reusing the same mesh.
    **inversion_params_l1
)

# Run the L1 time-lapse inversion.
print("Starting full L1 time-lapse inversion...")
result_full_l1 = inversion_full_l1.run() # Renamed result object
print("Full L1 time-lapse inversion complete!")

# %%
# --- Visualize Results of Full L1 Time-Lapse Inversion ---
# Plot the inverted resistivity models for each of the 12 timesteps using L1 regularization.
from palettable.lightbartlein.diverging import BlueDarkRed18_18 # Colormap (already imported).
fixed_cmap_l1 = BlueDarkRed18_18.mpl_colormap # Renamed for clarity if different style is desired.

fig_full_l1, axes_full_l1 = plt.subplots(3, 4, figsize=[16,6]) # 3 rows, 4 columns. Renamed.
axes_full_l1 = axes_full_l1.flatten() # Flatten axes array.

# Loop through each timestep and plot its L1 inverted resistivity model.
for i in range(12): # Assuming 12 timesteps.
    ax = axes_full_l1[i]
    # `result_full_l1.mesh` is the mesh.
    # `result_full_l1.final_models[:,i]` is the L1 inverted model for timestep `i`.
    # `result_full_l1.all_coverage` for masking.
    # Note: L1 inversion might produce sharper boundaries.
    _, cbar = pg.show(result_full_l1.mesh, result_full_l1.final_models[:,i], pad=0.3, orientation="vertical",
                      cMap=fixed_cmap_l1, cMin=100, cMax=3000, logScale=False,
                      ylabel="Elevation (m)", label='Resistivity ($\Omega$m)', ax=ax,
                      coverage=(result_full_l1.all_coverage[i] > -1 if result_full_l1.all_coverage is not None else None))
    cbar.remove() # Remove individual colorbars.
    ax.set_title(f"L1 - Timestep {measurement_times[i]}") # Title for each subplot.

fig_full_l1.tight_layout() # Adjust layout.
plt.suptitle("Full L1 Time-Lapse Inversion Results", fontsize=16, y=1.02) # Overall title.
plt.show() # Display the plot. Expected output: Figure with 12 subplots showing L1 results.

# %%
# This cell is empty in the original script.

# %%
# This cell is empty in the original script.
# End of Example 4.

# %%


# %%



