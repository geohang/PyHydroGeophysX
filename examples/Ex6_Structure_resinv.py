# Script-level comment:
# This script, Ex6_Structure_resinv.py, demonstrates how to perform a
# structure-constrained Electrical Resistivity Tomography (ERT) inversion.
# The structural information (e.g., layer boundaries) is derived from a
# preliminary Seismic Refraction Tomography (SRT) inversion.
#
# Workflow steps covered:
# 1. Data Loading:
#    - Loads synthetic seismic travel time data (from a previous example, e.g., Ex2 or Ex5).
#    - Loads synthetic ERT data (from a previous example, e.g., Ex3).
# 2. Initial ERT Mesh Creation:
#    - Creates a standard ERT mesh using PyGIMLi's ERTManager, based on the ERT data.
#      This mesh is primarily used here for the SRT inversion step.
# 3. Seismic Refraction Tomography (SRT) Inversion:
#    - Performs SRT inversion on the loaded travel time data using the ERT mesh
#      (or a mesh derived from it) to obtain a P-wave velocity model.
#    - Visualizes the resulting velocity model.
# 4. Velocity Model Post-processing (Thresholding):
#    - A simple thresholding approach is applied to the velocity model to classify
#      cells into two categories (e.g., above and below a certain velocity,
#      representing different geological units like overburden and bedrock).
#    - Visualizes the original and thresholded velocity models.
# 5. Velocity Interface Extraction:
#    - Defines and uses a function `extract_velocity_interface` to pick a line
#      representing a significant velocity contrast (e.g., the 1200 m/s contour).
#    - This involves binning, interpolation, and smoothing (Savitzky-Golay filter).
#    - Visualizes the original velocity model with the extracted interface line.
# 6. Structure-Constrained ERT Mesh Generation:
#    - Defines and uses a function `add_velocity_interface` to create a new ERT mesh.
#    - This function takes an initial ERT PLC (Planar Straight Line Complex), adds the
#      extracted velocity interface as a structural constraint, and re-meshes.
#    - Assigns different markers to regions above and below the interface within the survey area.
#    - Visualizes the new mesh with region markers.
# 7. (Implied Next Step) Structure-Constrained ERT Inversion:
#    - The generated `mesh_with_interface` is saved. This mesh would then be used
#      in an ERT inversion (not explicitly shown in this script's execution flow but is the goal).
#      The different region markers allow assigning distinct regularization parameters or
#      constraints during the ERT inversion, guided by the seismic structure.
#
# Assumptions:
# - Synthetic seismic travel time data (`synthetic_seismic_data.dat`) and ERT data
#   (`synthetic_data30.dat`) are available in specified hardcoded paths, likely
#   generated by previous examples in the PyHydroGeophysX suite.
# - The script defines custom helper functions (`extract_velocity_interface`, `add_velocity_interface`,
#   `fill_holes_2d`, `createTriangles`) which are part of this example's context.
#   (Note: `fill_holes_2d` and `createTriangles` are defined but not directly used for the main
#    structure-constrained mesh generation in this specific script flow, they seem related to
#    visualizing SRT results from Ex5 more generally).
#
# Expected output:
# - Console output: Progress messages from PyGIMLi's inversion.
# - Matplotlib plots:
#   - Initial ERT mesh.
#   - SRT inversion result (velocity model).
#   - Comparison of original and thresholded velocity models.
#   - Velocity model with the extracted interface line.
#   - The new ERT mesh incorporating the structural interface, with region markers.
# - Saved files:
#   - `mesh_with_interface.bms`: The structurally constrained ERT mesh.
#   - Other plots/data might be saved if uncommented or extended.
# - The primary outcome is the `mesh_with_interface.bms` file, which is ready for
#   structure-constrained ERT inversion.

"""
Ex 6. Structure-Constrained Resistivity Inversion
===========================================

This example demonstrates how to incorporate structural information from 
seismic velocity models into ERT inversion for improved subsurface imaging.

The workflow includes:
1. Loading seismic travel time data and performing velocity inversion
2. Extracting velocity interfaces at specified thresholds
3. Creating ERT meshes with geological layer boundaries
4. Structure-constrained ERT inversion using velocity-derived interfaces
5. Comparison with unconstrained inversion results

Structure-constrained inversion significantly improves the accuracy of 
resistivity models by incorporating a priori geological information,
leading to more reliable hydrological interpretations.
"""
# %%
# --- Standard library and third-party imports ---
import matplotlib.pyplot as plt
import numpy as np
import pygimli as pg # PyGIMLi for geophysical modeling, mesh, ERT, and SRT.
from pygimli.physics import ert # For ERT specific functionalities.
import pygimli.physics.traveltime as tt # For SRT (TravelTimeManager).
import os
import sys
import matplotlib.pylab as pylab # For custom Matplotlib styling.

# --- Setup package path for development ---
# Ensures the script can find PyHydroGeophysX when run directly.
try:
    # For regular Python scripts.
    current_dir = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback for interactive environments (e.g., Jupyter).
    current_dir = os.getcwd()

# Add the parent directory (project root) to Python path.
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

# --- Import PyHydroGeophysX modules ---
# `TimeLapseERTInversion` is imported but not directly used in this script's main flow.
# It might be intended for comparison or a later step not fully implemented here.
from PyHydroGeophysX.inversion.time_lapse import TimeLapseERTInversion

# --- Matplotlib styling parameters ---
# Set custom parameters for plot aesthetics (font sizes, family).
params = {'legend.fontsize': 15,
         'axes.labelsize': 14,
         'axes.titlesize':14,
         'xtick.labelsize':14,
         'ytick.labelsize':14}
pylab.rcParams.update(params)
plt.rcParams["font.family"] = "Arial"

# %%
# --- Define Output Directory ---
# Specifies where results (e.g., the structured mesh) will be saved.
# IMPORTANT: This uses a hardcoded absolute path. Users should modify this.
# SUGGESTION: Use a relative path for better portability:
# output_dir_struct_inv = os.path.join(current_dir, "results", "Ex6_Structure_Inversion_results")
output_dir = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples/results/Structure_WC" # User-specific path.
os.makedirs(output_dir, exist_ok=True) # Create directory if it doesn't exist.

# %% [markdown]
# ##  load data
# <!-- This section loads the necessary input data: seismic travel times and ERT data. -->
# <!-- These datasets are assumed to have been generated or acquired previously. -->

# %%
# --- Load Seismic Travel Time Data ---
# Path to the synthetic seismic travel time data file (e.g., from Ex2 or Ex5).
# IMPORTANT: Hardcoded absolute path.
seismic_data_path = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples//results/workflow_example/synthetic_seismic_data.dat"
ttData = tt.load(seismic_data_path) # Load travel time data using PyGIMLi.

# --- Load ERT Data ---
# Path to a synthetic ERT data file (e.g., for a specific timestep from Ex3).
# IMPORTANT: Hardcoded absolute path.
ert_data_path = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples//results/TL_measurements/appres/synthetic_data30.dat"
ertData = ert.load(ert_data_path) # Load ERT data.

# %%
# --- Initial ERT Mesh Creation (Primarily for SRT Inversion Context) ---
# This section creates a mesh based on the ERT array configuration.
# While the script's goal is a structure-constrained ERT mesh, this initial mesh
# is used here as the basis for the SRT (seismic) inversion.
# `paraBoundary` controls the lateral extent of the refined mesh region.
paraBoundary = 0.1 # Small padding for the parametric domain.

ert1 = ert.ERTManager(ertData) # Initialize ERTManager with the loaded ERT data.
# Create a mesh tailored to the ERT data configuration.
# Parameters control mesh refinement, depth, and boundary cell sizes.
grid = ert1.createMesh(data=ertData, quality=31, paraDX=0.5, paraMaxCellSize=2,
                       boundaryMaxCellSize=3000, smooth=[2, 2],
                       paraBoundary=paraBoundary, paraDepth=30.0)
ert1.setMesh(grid) # Assign this mesh to the ERTManager instance.
# Extract the primary inversion domain (parameter domain) from the mesh created by ERTManager.
mesh = ert1.fop.paraDomain # This `mesh` will be used for the SRT inversion.
# Set a uniform cell marker (e.g., 2) for all cells in this mesh.
# This is often done before using it in a different physics inversion (like SRT here)
# or before incorporating further structural information.
mesh.setCellMarkers(np.ones((mesh.cellCount()))*2)
pg.show(mesh, markers=True, showMesh=True) # Display the mesh with markers.
plt.title("Initial Mesh for SRT Inversion (Derived from ERT Setup)")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.show()

# %%
# --- Seismic Refraction Tomography (SRT) Inversion ---
# Perform SRT inversion using the loaded travel time data (`ttData`) and the mesh created above.
TT = pg.physics.traveltime.TravelTimeManager() # Initialize TravelTimeManager.
TT.setMesh(mesh) # Set the mesh for the SRT inversion.
# Run the inversion. Parameters include:
# `lam`: Regularization strength.
# `zWeight`: Weight for vertical smoothness relative to horizontal.
# `vTop`, `vBottom`: Optional constraints on velocity at the top/bottom of the model.
# `limits`: Min/max allowed velocities in the inverted model [m/s].
TT.invert(ttData, lam=50,
          zWeight=0.2,vTop=500, vBottom=5000,
          verbose=1, limits=[100., 6000.])
# The resulting velocity model is stored in `TT.model`.

# %%
# --- Visualize SRT Inversion Result with Coverage ---
# `TT.showResult` displays the inverted velocity model.
# `coverage=TT.standardizedCoverage()` uses ray coverage to mask poorly resolved areas.
ax_srt_result_cov, cbar_srt_result_cov = TT.showResult(cMap='jet', coverage=TT.standardizedCoverage(),
                                                       cMin=500, cMax=5000)
ax_srt_result_cov.set_title("SRT Inversion Result with Coverage")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.show() # Output: Matplotlib plot of velocity model.

# %%
# --- Visualize SRT Inversion Result without Coverage Mask ---
# Shows the full velocity model without masking based on ray coverage.
ax_srt_result_full, cbar_srt_result_full = TT.showResult(cMap='jet', cMin=500, cMax=5000)
ax_srt_result_full.set_title("SRT Inversion Result (Full Model)")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.show() # Output: Matplotlib plot.

# %%
# This cell seems to be for debugging or inspecting the mesh and model directly.
# It prints the mesh object and the velocity model array.

# %%
# --- Display Inverted Velocity Model on ParaDomain ---
# `TT.paraDomain` should be the same as `mesh` if `TT.setMesh(mesh)` was used.
# `TT.model.array()` gives the velocity values for each cell.
pg.show(TT.paraDomain, TT.model.array())
plt.title("SRT Velocity Model on Inversion Mesh")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.show()
print("SRT Inversion Mesh Object:", TT.paraDomain)
print("SRT Inverted Velocity Model Array (first 10 values):", TT.model.array()[:10])

# %%
# --- Thresholding the Velocity Model ---
# This section applies a simple threshold to the inverted velocity model
# to classify cells into two categories (e.g., overburden vs. bedrock).
# This is a basic way to derive structural information.
import numpy as np # Already imported.

# Get the velocity values from the SRT inversion result.
velocity_data = TT.model.array()

# Get cell center coordinates from the SRT inversion mesh.
# `mesh` here refers to `TT.paraDomain`.
mesh_srt_inv = TT.paraDomain # Use a clearer variable name.
cell_centers_srt = mesh_srt_inv.cellCenters() # Renamed
x_coords_srt = cell_centers_srt[:,0]  # X-coordinates of cell centers. Renamed.
z_coords_srt = cell_centers_srt[:,1]  # Z-coordinates (depth/elevation) of cell centers. Renamed.

# Initialize an array for the thresholded model, default to marker 1.
thresholded_model = np.ones_like(velocity_data, dtype=int) # Renamed

# Get unique x-coordinates (representing vertical columns of cells).
unique_x_coords_srt = np.unique(x_coords_srt) # Renamed

# Iterate through each vertical column of cells.
for x_val in unique_x_coords_srt: # Renamed loop var
    # Get indices of cells in the current column, sorted by depth/elevation.
    column_indices = np.where(x_coords_srt == x_val)[0]
    # Sorting by z_coords_srt ensures processing from top to bottom (if z is elevation and increases upwards)
    # or shallow to deep (if z is depth and increases downwards).
    column_indices_sorted = column_indices[np.argsort(z_coords_srt[column_indices])] # Renamed

    threshold_crossed_in_column = False # Flag to mark if threshold has been met in this column. Renamed.

    # Process cells in the current column.
    for idx in column_indices_sorted:
        # If velocity at this cell is >= 1200 m/s OR if threshold was already crossed higher up in this column:
        if velocity_data[idx] >= 1200 or threshold_crossed_in_column:
            thresholded_model[idx] = 2 # Assign marker 2 (e.g., bedrock).
            threshold_crossed_in_column = True # Set flag for remaining cells in this column.
        # Otherwise, `thresholded_model[idx]` remains 1 (e.g., overburden).

# --- Visualize Original and Thresholded Velocity Models ---
import matplotlib.pyplot as plt # Already imported.

# Create a figure with two subplots for comparison.
fig_thresh, (ax1_thresh, ax2_thresh) = plt.subplots(1, 2, figsize=(12, 6)) # Renamed

# Plot 1: Original Inverted Velocity Data
pg.show(mesh_srt_inv, velocity_data, ax=ax1_thresh, cMap='viridis', colorBar=True,
        label="Velocity (m/s)") # Added label
ax1_thresh.set_title('Original Inverted Velocity')
ax1_thresh.set_xlabel("Distance (m)")
ax1_thresh.set_ylabel("Elevation (m)")


# Plot 2: Thresholded Velocity Data (Structural Model)
pg.show(mesh_srt_inv, thresholded_model, ax=ax2_thresh, cMap='jet', colorBar=True,
        label="Material ID") # Added label
ax2_thresh.set_title('Thresholded Velocity (Structure)')
ax2_thresh.set_xlabel("Distance (m)")
ax2_thresh.set_ylabel("Elevation (m)")


plt.tight_layout()
plt.show() # Output: Matplotlib plot showing two models.

# %%
# --- Define Function to Extract Velocity Interface ---
# This function identifies an interface (e.g., bedrock) based on a velocity threshold.
# It processes the mesh column by column, interpolates the threshold depth,
# and then smooths the resulting interface line.
from scipy.interpolate import interp1d # For interpolation.

def extract_velocity_interface(mesh_obj, velocity_model_data, threshold_val=1200, x_interval=4.0 ): # Renamed args
    """
    Extract an interface line where cell velocity equals a specified threshold value.
    
    Parameters:
    mesh_obj : pygimli.Mesh
        The PyGIMLi mesh object on which `velocity_model_data` is defined.
    velocity_model_data : numpy.ndarray
        Array of velocity values for each cell in `mesh_obj`.
    threshold_val : float, optional
        The velocity value that defines the interface (default: 1200 m/s).
    x_interval : float, optional
        Spacing between x-coordinate points for binning when searching for the interface (default: 4.0 m).

    Returns:
    tuple (numpy.ndarray, numpy.ndarray)
        - x_dense: X-coordinates of the smoothed interface line (dense points).
        - z_dense: Z-coordinates (elevation/depth) of the smoothed interface line.
    """
    # Get cell center coordinates from the mesh.
    cell_centers_coords = mesh_obj.cellCenters() # Renamed
    x_coords_cells = cell_centers_coords[:,0] # Renamed
    z_coords_cells = cell_centers_coords[:,1] # Renamed
    
    # Determine the overall x-range of the mesh for complete boundary definition.
    x_min_mesh, x_max_mesh = np.min(x_coords_cells), np.max(x_coords_cells) # Renamed
    
    # Create x-coordinate bins across the entire x-range for systematically searching the interface.
    x_bins_interface = np.arange(x_min_mesh, x_max_mesh + x_interval, x_interval) # Renamed
    
    # Initialize lists to store the (x, z) coordinates of raw interface points found.
    interface_x_raw = [] # Renamed
    interface_z_raw = [] # Renamed
    
    # Iterate through each x-bin to find the interface depth within that vertical slice.
    for i in range(len(x_bins_interface)-1):
        # Get indices of cells whose centers fall horizontally within the current x-bin.
        bin_indices_loop = np.where((x_coords_cells >= x_bins_interface[i]) & (x_coords_cells < x_bins_interface[i+1]))[0] # Renamed
        
        if len(bin_indices_loop) > 0: # If cells exist in this bin.
            # Get velocity values and z-coordinates (depths/elevations) for cells in this bin.
            bin_velocities_loop = velocity_model_data[bin_indices_loop] # Renamed
            bin_depths_loop = z_coords_cells[bin_indices_loop] # Renamed
            
            # Sort these cells by z-coordinate to enable searching along a pseudo-vertical profile.
            sort_indices_depth = np.argsort(bin_depths_loop) # Renamed
            bin_velocities_sorted_loop = bin_velocities_loop[sort_indices_depth] # Renamed
            bin_depths_sorted_loop = bin_depths_loop[sort_indices_depth] # Renamed
            
            # Find where velocity crosses the threshold within this sorted column.
            for j in range(1, len(bin_velocities_sorted_loop)):
                v1_interp, v2_interp = bin_velocities_sorted_loop[j-1], bin_velocities_sorted_loop[j] # Renamed
                z1_interp, z2_interp = bin_depths_sorted_loop[j-1], bin_depths_sorted_loop[j] # Renamed

                # Check for threshold crossing between cell j-1 and cell j.
                if (v1_interp < threshold_val and v2_interp >= threshold_val) or \
                   (v1_interp >= threshold_val and v2_interp < threshold_val):
                    # Linear interpolation to find a more precise z-coordinate for the threshold.
                    # Avoid division by zero if velocities are equal (though crossing implies they differ unless threshold is one of them).
                    if v2_interp == v1_interp:
                        interpolated_interface_depth = z1_interp
                    else:
                        ratio_interp = (threshold_val - v1_interp) / (v2_interp - v1_interp) # Renamed
                        interpolated_interface_depth = z1_interp + ratio_interp * (z2_interp - z1_interp) # Renamed
                    
                    # Store the midpoint of the bin's x-range and the interpolated interface depth.
                    interface_x_raw.append((x_bins_interface[i] + x_bins_interface[i+1]) / 2.0)
                    interface_z_raw.append(interpolated_interface_depth)
                    break # Found interface in this bin, move to next bin.
    
    # --- Extrapolate interface to mesh boundaries if needed ---
    # Ensure interface points span the entire x_min_mesh to x_max_mesh range.
    # Convert to numpy arrays for easier manipulation if points were found.
    if not interface_x_raw: # If no interface points were found at all.
        print("Warning: No interface points found for the given threshold.")
        return np.array([]), np.array([]) # Return empty arrays.

    interface_x_np = np.array(interface_x_raw) # Renamed
    interface_z_np = np.array(interface_z_raw) # Renamed

    # Extrapolate at the beginning (x_min_mesh) if necessary.
    if interface_x_np[0] > x_min_mesh + x_interval: # If first found point is far from mesh start.
        interface_x_np = np.insert(interface_x_np, 0, x_min_mesh)
        if len(interface_x_np) > 2: # Need at least two points (original first + new start) to make a slope.
                                    # Slope based on what were the first two actual points.
            slope_start_extrap = (interface_z_np[2] - interface_z_np[1]) / (interface_x_np[2] - interface_x_np[1]) # Renamed
            interface_z_np = np.insert(interface_z_np, 0, interface_z_np[1] - slope_start_extrap * (interface_x_np[1] - x_min_mesh))
        else: # Not enough points for slope, extrapolate horizontally from first actual point.
            interface_z_np = np.insert(interface_z_np, 0, interface_z_np[0]) # This uses the z of original first point.
    
    # Extrapolate at the end (x_max_mesh) if necessary.
    if interface_x_np[-1] < x_max_mesh - x_interval: # If last found point is far from mesh end.
        interface_x_np = np.append(interface_x_np, x_max_mesh)
        if len(interface_x_np) > 2: # Need at least two points (original last + new end) to make a slope.
                                    # Slope based on what were the last two actual points before appending.
            slope_end_extrap = (interface_z_np[-3] - interface_z_np[-4]) / (interface_x_np[-3] - interface_x_np[-4]) # Renamed
            interface_z_np = np.append(interface_z_np, interface_z_np[-2] + slope_end_extrap * (x_max_mesh - interface_x_np[-2]))
        else: # Not enough points for slope, extrapolate horizontally.
            interface_z_np = np.append(interface_z_np, interface_z_np[-1]) # This uses z of original last point.
    
    # --- Smooth the extracted interface line ---
    # Create a dense grid of x-coordinates for generating a smooth interpolated interface.
    x_dense_smooth = np.linspace(x_min_mesh, x_max_mesh, 500)  # 500 points for a visually smooth curve. Renamed.
    
    # Apply cubic interpolation for a smoother interface if enough points exist.
    if len(interface_x_np) > 3: # Cubic interpolation generally requires at least 4 points.
        try:
            interp_func_cubic = interp1d(interface_x_np, interface_z_np, kind='cubic',
                                         bounds_error=False, fill_value="extrapolate") # Renamed
            z_dense_interp = interp_func_cubic(x_dense_smooth) # Renamed
            
            # Apply Savitzky-Golay filter for additional smoothing if enough points.
            from scipy.signal import savgol_filter # Import locally if not already at top.
            if len(z_dense_interp) > 31: # Ensure enough points for the filter window.
                 z_dense_smooth = savgol_filter(z_dense_interp, window_length=31, polyorder=3) # Renamed
            else:
                 z_dense_smooth = z_dense_interp # Use cubic if not enough for Sav-Gol.
        except Exception as e_smooth: # Catch potential errors during cubic interpolation or smoothing. Renamed.
            print(f"Warning: Cubic interpolation/smoothing failed ({e_smooth}). Falling back to linear.")
            # Fall back to linear interpolation if cubic or Sav-Gol fails.
            interp_func_linear = interp1d(interface_x_np, interface_z_np, kind='linear',
                                          bounds_error=False, fill_value="extrapolate") # Renamed
            z_dense_smooth = interp_func_linear(x_dense_smooth)
    elif len(interface_x_np) > 0: # If 1-3 points, use linear interpolation (or constant if 1 point).
        interp_func_linear = interp1d(interface_x_np, interface_z_np, kind='linear',
                                      bounds_error=False, fill_value="extrapolate")
        z_dense_smooth = interp_func_linear(x_dense_smooth)
    else: # No interface points were found earlier.
        z_dense_smooth = np.array([]) # Return empty array if no points.

    return x_dense_smooth, z_dense_smooth


# %%
# --- Extract the Velocity Interface ---
# Call the function `extract_velocity_interface` using the SRT inversion mesh (`mesh_srt_inv` which is `TT.paraDomain`)
# and the inverted velocity model (`velocity_data` which is `TT.model.array()`).
# A threshold of 1200 m/s is used to define the interface, with an x-binning interval of 5m.
smooth_x_interface, smooth_z_interface = extract_velocity_interface(mesh_srt_inv, velocity_data, threshold=1200, interval=5) # Renamed outputs

# %%
# --- Visualize the Extracted Interface on the Velocity Model ---
fig_vel_interface, ax_vel_interface = plt.subplots(1, 1, figsize=(12, 6)) # Renamed

# Display the original inverted velocity model.
pg.show(mesh_srt_inv, velocity_data, ax=ax_vel_interface, cMap='viridis', colorBar=True,
        label="Velocity (m/s)") # Added label
ax_vel_interface.set_title('Inverted Velocity Model with Extracted Interface')
# Overlay the extracted smooth interface line on the plot.
ax_vel_interface.plot(smooth_x_interface, smooth_z_interface, color='red', linewidth=2, label='1200 m/s Interface') # Added label & style
ax_vel_interface.legend()
ax_vel_interface.set_xlabel("Distance (m)")
ax_vel_interface.set_ylabel("Elevation (m)")
plt.show() # Output: Matplotlib plot.

# %%
# This cell appears to be for creating a basic PLC from ERT data, possibly as a starting point
# before adding the structural interface. It's not directly used in the `add_velocity_interface` below
# which creates its own initial PLC.

# %%
# --- Create a Default ERT Mesh Geometry (PLC) ---
# This creates a Planar Straight Line Complex (PLC) based on the ERT sensor layout.
# This `geo_initial_ert` could serve as a base geometry if `add_velocity_interface` didn't create its own.
# `paraMaxCellSize`, `paraBoundary`, `paraDepth`, `boundaryMaxCellSize` control the PLC generation.
geo_initial_ert = pg.meshtools.createParaMeshPLC(ertData, quality=31, paraMaxCellSize=5, # Renamed
                                                 paraBoundary=paraBoundary, paraDepth=30.0, boundaryMaxCellSize=200)

pg.show(geo_initial_ert) # Display this initial ERT PLC.
plt.title("Initial ERT PLC Geometry (before structure)")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.show() # Output: Matplotlib plot.


# %%
# --- Define Function to Add Velocity Interface to ERT Mesh Geometry ---
# This function takes an ERT data container (for sensor positions), the extracted smooth interface,
# and creates a new mesh that incorporates this interface as a structural boundary.
# It assigns different markers to regions above and below the interface.
def add_velocity_interface(ert_data_container, smooth_x_coords, smooth_z_coords, # Renamed args for clarity
                           para_boundary_extend=2, boundary_marker_val=1): # Renamed args
    """
    Add a velocity interface line to an ERT geometry and create a mesh with distinct region markers.
    Markers are assigned as:
    - Cells outside the main survey area (padding): `boundary_marker_val` (default 1).
    - Cells inside survey area, above the velocity interface: marker 3 (arbitrarily chosen).
    - Cells inside survey area, below the velocity interface: marker 2 (arbitrarily chosen).
    
    Parameters:
    ert_data_container : pygimli.DataContainer
        ERT data container with sensor positions.
    smooth_x_coords : numpy.ndarray
        X-coordinates of the smoothed velocity interface line.
    smooth_z_coords : numpy.ndarray
        Z-coordinates (elevation/depth) of the smoothed velocity interface line.
    para_boundary_extend : float, optional
        Lateral extension for the parametric domain of the initial PLC (default: 2 units).
    boundary_marker_val : int, optional
        Marker for cells outside the main survey area (default: 1).

    Returns:
    tuple (numpy.ndarray, pygimli.Mesh)
        - markers_final: Array of cell markers for the new mesh.
        - mesh_with_struct_interface: The created mesh incorporating the structural interface.
    """
    # Create an initial PLC based on ERT sensor layout using `createParaMeshPLC`.
    # This defines a basic rectangular domain with refinement around sensors.
    geo_base_ert = pg.meshtools.createParaMeshPLC(ert_data_container, quality=32, paraMaxCellSize=30, # Renamed
                                                 paraBoundary=para_boundary_extend, paraDepth=30.0,
                                                 boundaryMaxCellSize=500)
    
    # Combine the x and z coordinates of the smoothed interface into a list of [x,z] points.
    interface_points_list = np.vstack((smooth_x_coords, smooth_z_coords)).T # Renamed
    
    # Extend the interface line horizontally at both ends to ensure it spans the full model width.
    # The z-value at the extended points is kept the same as the first/last point of the interface.
    # This prevents issues with the interface not reaching model boundaries.
    extended_interface_points = np.vstack(( # Renamed
        np.array([[interface_points_list[0,0] - para_boundary_extend, interface_points_list[0,1]]]), # Extend left
        interface_points_list, # Original points
        np.array([[interface_points_list[-1,0] + para_boundary_extend, interface_points_list[-1,1]]]) # Extend right
    ))
    
    # Create a PyGIMLi PLC segment (a polyline) representing the extended velocity interface.
    # `isClosed=False` means it's a line, not a filled polygon.
    # `marker=99` is a temporary marker for the line itself, often used to ensure it's meshed.
    interface_line_plc = pg.meshtools.createPolygon(extended_interface_points.tolist(), isClosed=False, # Renamed
                                                    interpolate='linear', marker=99)
    
    # Add this interface line PLC segment to the base ERT geometry.
    # The `+` operator merges these PLC objects.
    geo_combined_with_interface = geo_base_ert + interface_line_plc # Renamed
    
    # Create a new mesh from the combined geometry.
    # The meshing algorithm will honor the `interface_line_plc` as an internal boundary.
    # `quality=28` controls the mesh element quality (e.g., minimum angles).
    mesh_with_struct_interface = pg.meshtools.createMesh(geo_combined_with_interface, quality=28) # Renamed
    
    # --- Assign Region Markers to the New Mesh ---
    # Initialize all cell markers to `boundary_marker_val` (default 1), representing cells outside the primary survey focus.
    markers_final = np.ones(mesh_with_struct_interface.cellCount(), dtype=int) * boundary_marker_val # Renamed
    
    # Define the horizontal extent of the "survey area" where markers 2 and 3 will be assigned.
    # This is based on the first and last ERT sensor positions, extended by `para_boundary_extend`.
    survey_left_boundary = ert_data_container.sensors()[0][0] - para_boundary_extend # Renamed
    survey_right_boundary = ert_data_container.sensors()[-1][0] + para_boundary_extend # Renamed
    
    # Iterate through each cell of the new mesh to assign markers based on position relative to the interface.
    for i, cell_obj_loop in enumerate(mesh_with_struct_interface.cells()): # Renamed loop var
        cell_center_x = cell_obj_loop.center().x() # X-coordinate of cell center. Renamed.
        cell_center_y = cell_obj_loop.center().y() # Y-coordinate (elevation/depth) of cell center. Renamed.
        
        # Only modify markers for cells within the defined horizontal survey area.
        if survey_left_boundary <= cell_center_x <= survey_right_boundary:
            # Interpolate the y-coordinate (elevation/depth) of the interface at the cell's x-coordinate.
            interface_y_at_cell = np.interp(cell_center_x, extended_interface_points[:, 0], extended_interface_points[:, 1]) # Renamed
            
            # Assign marker based on cell center's position relative to the interface.
            # The original script's logic `abs(cell_y) < abs(interface_y)` for marker 2 (Below)
            # can be ambiguous depending on coordinate system (y as depth vs. elevation, and origin).
            # Assuming 'y' is elevation (increases upwards):
            #   - If cell_center_y > interface_y_at_cell -> cell is Above interface -> marker 3
            #   - If cell_center_y <= interface_y_at_cell -> cell is Below interface -> marker 2
            # This interpretation aligns with typical geophysical conventions.
            if cell_center_y > interface_y_at_cell: # Cell is above the interface
                markers_final[i] = 3  # Assign marker for "above interface" region.
            else: # Cell is below or on the interface
                markers_final[i] = 2  # Assign marker for "below interface" region.
    
    # Ensure cells that were originally part of the far-field boundary in `geo_base_ert`
    # (and subsequently in `mesh_with_struct_interface` if not overridden by the loop above)
    # retain their `boundary_marker_val`. This step might be redundant if the loop logic is sufficient.
    # It primarily ensures that cells marked by `createParaMeshPLC` as padding/boundary (often marker 1) keep that marker.
    # markers_final[mesh_with_struct_interface.cellMarkers() == boundary_marker_val] = boundary_marker_val # Original line was `... == 1`
    # More robust: if a cell's original PLC-derived marker was `boundary_marker_val`, keep it.
    plc_original_markers = mesh_with_struct_interface.cellMarkers() # Get markers derived from PLC regions.
    markers_final[plc_original_markers == boundary_marker_val] = boundary_marker_val

    # Set the newly defined markers in the mesh object.
    mesh_with_struct_interface.setCellMarkers(markers_final)
    
    return markers_final, mesh_with_struct_interface

# Example usage comment from original script (conceptual):
# # markers, meshafter = add_velocity_interface(ertData, smooth_x, smooth_z)
# # pg.show(meshafter, markers=True, label='Region markers')

# %%
# --- Generate and Visualize the Structurally Constrained ERT Mesh ---
# Call `add_velocity_interface` using the loaded ERT data (`ertData`) and the
# extracted smooth velocity interface (`smooth_x_interface`, `smooth_z_interface`).
markers_struct_mesh, mesh_with_interface = add_velocity_interface(ertData, smooth_x_interface, smooth_z_interface) # Renamed vars
# `mesh_with_interface` is the new ERT mesh incorporating the seismic structure.
# `markers_struct_mesh` contains the region markers for this new mesh.
print("Structurally constrained mesh generated:", mesh_with_interface)

# %%
# --- Plot the Structurally Constrained Mesh with Region Markers ---
fig_struct_mesh, ax_struct_mesh = plt.subplots(figsize=(10, 6)) # Renamed
# Display the mesh, coloring cells by their assigned markers.
pg.show(mesh_with_interface, data=markers_struct_mesh, ax=ax_struct_mesh, cMap='jet', colorBar=True, label="Region Markers")
ax_struct_mesh.set_title('Structurally Constrained ERT Mesh with Region Markers')
ax_struct_mesh.set_xlabel("Distance (m)")
ax_struct_mesh.set_ylabel("Elevation (m)")
plt.show() # Output: Matplotlib plot.

# %%
# --- Further Visualization of the Structurally Constrained Mesh ---
# This cell provides another view of the mesh, possibly for zooming or different styling.
ax_detail_struct_mesh, cbar_detail_struct_mesh = pg.show(mesh_with_interface, data=markers_struct_mesh, cMap='jet') # Renamed, used markers
ax_detail_struct_mesh.set_xlim([-10,120]) # Set x-axis limits for zoom.
ax_detail_struct_mesh.set_ylim([1580,1630]) # Set y-axis limits for zoom.
ax_detail_struct_mesh.set_title("Detailed View of Structurally Constrained Mesh")
ax_detail_struct_mesh.set_xlabel("Distance (m)")
ax_detail_struct_mesh.set_ylabel("Elevation (m)")
if cbar_detail_struct_mesh: cbar_detail_struct_mesh.set_label("Region Markers") # Add label to colorbar
plt.show() # Output: Matplotlib plot.

# %%
# --- Save the Structurally Constrained Mesh ---
# The final mesh, incorporating the seismic interface, is saved to a file.
# This mesh is now ready to be used for a structure-constrained ERT inversion.
structured_mesh_save_path = os.path.join(output_dir, "mesh_with_interface.bms") # Renamed
mesh_with_interface.save(structured_mesh_save_path)
print(f"Structurally constrained ERT mesh saved to: {structured_mesh_save_path}")
# End of Example 6.





