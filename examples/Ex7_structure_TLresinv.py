# Script-level comment:
# This script, Ex7_structure_TLresinv.py, demonstrates an advanced workflow:
# structure-constrained time-lapse Electrical Resistivity Tomography (ERT) inversion.
# It leverages a pre-existing mesh that incorporates geological structures (presumably derived
# from seismic data, as hinted by Ex6) to guide the time-lapse ERT inversion.
# The ultimate goal, though partially commented out, is to convert the resulting
# time-lapse resistivity models into water content and perform uncertainty analysis.
#
# Workflow steps covered (and implied):
# 1. Data Loading:
#    - Loads a sequence of time-lapse ERT data files (e.g., monthly measurements).
#    - Loads a pre-existing structurally constrained mesh (e.g., "mesh_with_interface.bms" from Ex6).
# 2. Time-Lapse ERT Inversion (Windowed Approach):
#    - Sets up and runs a windowed time-lapse ERT inversion using `WindowedTimeLapseERTInversion`.
#    - This approach processes data in overlapping temporal windows, suitable for large time-series.
#    - The key is that it uses the *structurally constrained mesh* for all inversions,
#      meaning the regularization and model structure respect the predefined geological layers.
# 3. Saving Results:
#    - Saves the resulting time-series of inverted resistivity models and associated coverage arrays.
#    - Saves the mesh used for inversion (which is the structurally constrained one).
# 4. Visualization:
#    - Plots the inverted resistivity models for all timesteps in a grid to show
#      the temporal evolution of subsurface resistivity.
#    - Includes markers for specific points of interest on the first timestep's plot.
# 5. (Commented Out) Conversion to Water Content and Uncertainty Analysis:
#    - The script contains commented-out sections that would use `ERTtoWC` for:
#        - Converting the time-lapse resistivity models to water content models using
#          layer-specific petrophysical parameters.
#        - Performing Monte Carlo simulations to quantify uncertainty in the water content estimates.
#        - Extracting and plotting time-series of water content (mean and percentiles) at specific locations.
#
# Assumptions:
# - Time-lapse ERT data files (e.g., "synthetic_data30.dat", ...) are available in the `data_dir`.
#   These are likely outputs from Ex3.
# - A structurally constrained mesh (`mesh_with_interface.bms`) is available, presumably generated by Ex6.
# - Paths for data loading and saving results are hardcoded and may need user adjustment.
#
# Expected output:
# - Console output: Progress messages from the windowed time-lapse inversion.
# - Saved files:
#   - `resmodel.npy`: Array of inverted resistivity models for all timesteps.
#   - `all_coverage.npy`: Array of coverage values for all timesteps.
#   - `mesh_res.bms`: The structurally constrained mesh used for the inversion.
#   - (If uncommented) Files related to water content conversion and Monte Carlo analysis from `ERTtoWC`.
# - Matplotlib plots:
#   - A figure showing the grid of 12 inverted resistivity models over time.
#   - (If uncommented) Plots of water content statistics and time-series.

"""
Ex 7. Structure-Constrained Time-Lapse Resistivity Inversion
======================================================

This example combines structural constraints with time-lapse ERT inversion
to monitor water content changes in layered geological media.

The workflow demonstrates:
1. Loading meshes with geological structure from seismic interpretation
2. Time-lapse ERT inversion with structural constraints
3. Converting resistivity to water content using layer-specific petrophysics
4. Uncertainty quantification through Monte Carlo analysis
5. Time series analysis of water content at specific locations

This advanced approach provides the most reliable estimates of subsurface
water content evolution by combining temporal, spatial, and geological
constraints in the inversion process.
"""
# --- Standard library and third-party imports ---
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
import pygimli as pg # PyGIMLi for geophysical modeling, mesh handling, and ERT.
from pygimli.physics import ert # Specifically for ERT related tasks.
from mpl_toolkits.axes_grid1 import make_axes_locatable # For advanced colorbar placement.

# --- Setup package path for development ---
# Ensures the script can find PyHydroGeophysX when run directly from the examples folder.
try:
    # For regular Python scripts where __file__ is defined.
    current_dir = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback for interactive environments like Jupyter notebooks.
    current_dir = os.getcwd()

# Add the parent directory (project root) to the Python path.
parent_dir = os.path.dirname(current_dir) # Navigate one level up.
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

# --- Import PyHydroGeophysX specific modules ---
# Import classes for time-lapse ERT inversion.
# `TimeLapseERTInversion` is for full simultaneous inversion (not used here).
# `WindowedTimeLapseERTInversion` is used for processing data in temporal windows.
from PyHydroGeophysX.inversion.time_lapse import TimeLapseERTInversion
from PyHydroGeophysX.inversion.windowed import WindowedTimeLapseERTInversion

# %%
# --- Define Path to Time-Lapse ERT Data ---
# `data_dir` should point to the directory containing the sequence of ERT data files.
# These files are assumed to be outputs from a previous synthetic data generation step (e.g., Ex3).
# IMPORTANT: This is a hardcoded absolute path. Users must change this to their data location.
# SUGGESTION: Use a relative path for better portability.
data_dir = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples/results/TL_measurements/appres"

# --- List of ERT Data Files ---
# These filenames represent a sequence of ERT measurements taken over time (e.g., monthly).
# They correspond to synthetic data generated for different days (30, 60, ..., 360).
ert_files = [
    "synthetic_data30.dat", "synthetic_data60.dat", "synthetic_data90.dat",
    "synthetic_data120.dat", "synthetic_data150.dat", "synthetic_data180.dat",
    "synthetic_data210.dat", "synthetic_data240.dat", "synthetic_data270.dat",
    "synthetic_data300.dat", "synthetic_data330.dat", "synthetic_data360.dat",
]


# --- Prepare Full Data File Paths and Measurement Times ---
# Construct the full path for each ERT data file.
data_files = [os.path.join(data_dir, f) for f in ert_files]

# Define measurement times. These can be simple indices, day numbers, or actual timestamps.
# They are used for temporal regularization and ordering the datasets.
# Here, they correspond to the "day" of the measurement in the synthetic example.
measurement_times = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # Representing months or sequence number.

# --- Load Structurally Constrained Mesh ---
# This mesh is assumed to have been created in a previous step (e.g., Ex6_Structure_resinv.py)
# where structural information (like layer boundaries from seismic inversion) was incorporated.
# IMPORTANT: Hardcoded absolute path to the mesh file.
mesh_file_path = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples/results/Structure_WC/mesh_with_interface.bms"
mesh_with_interface = pg.load(mesh_file_path) # Load the .bms mesh file.


# %%
# --- Set Up Parameters for Windowed Time-Lapse Inversion ---
# These parameters control the behavior of the inversion algorithm.
inversion_params = {
    "lambda_val": 10.0,              # Spatial regularization strength (smoothness).
    "alpha": 10.0,                   # Temporal regularization strength (coupling between timesteps within a window).
    "decay_rate": 0.0,               # Decay rate for temporal regularization (0.0 = constant coupling).
    "method": "cgls",                # Solver for the linear system (Conjugate Gradient Least Squares).
    "model_constraints": (0.001, 1e4), # Min/max allowed resistivity values (Ohm-m).
    "max_iterations": 15,            # Maximum number of Gauss-Newton iterations per window.
    "absoluteUError": 0.0,           # Absolute data error component.
    "relativeError": 0.05,           # Relative data error component (e.g., 5%).
    "lambda_rate": 1.0,              # Factor to reduce lambda_val per iteration (1.0 = no reduction).
    "lambda_min": 1.0,               # Minimum lambda_val if reduction is applied.
    "inversion_type": "L2"           # Norm for model regularization ('L1', 'L2', or 'L1L2'). L2 promotes smooth models.
}

# Define the window size for the windowed time-lapse inversion.
# This specifies how many consecutive timesteps are processed together in each sliding window.
window_size = 3  # Example: A window size of 3 means each inversion includes 3 datasets.

# --- Create and Run Windowed Time-Lapse Inversion ---
# Instantiate the `WindowedTimeLapseERTInversion` class.
# This object will manage the sequential inversion of temporal windows.
inversion_windowed_struct = WindowedTimeLapseERTInversion( # Renamed for clarity
    data_dir=data_dir,                   # Directory containing ERT data files (used if ert_files are relative).
    ert_files=ert_files,                 # List of ERT data filenames.
    measurement_times=measurement_times, # List/array of measurement times.
    window_size=window_size,             # Number of timesteps per window.
    mesh=mesh_with_interface,            # The structurally constrained mesh.
    **inversion_params                   # Pass other inversion parameters.
)

# Run the windowed time-lapse inversion.
# The `run` method iterates through the data, processing it window by window.
print("Starting windowed time-lapse inversion with structural constraints...")
result_windowed_struct = inversion_windowed_struct.run() # Renamed result object
print("Windowed time-lapse inversion complete!")


# %%
# --- Process and Save Inversion Results ---
# Convert the list of final models from each window into a 2D NumPy array.
# Shape: (number_of_mesh_cells, number_of_timesteps).
result_windowed_struct.final_models = np.array(result_windowed_struct.final_models)
print(f"Shape of final inverted models array: {result_windowed_struct.final_models.shape}")
# Convert coverage list to NumPy array as well.
result_windowed_struct.all_coverage = np.array(result_windowed_struct.all_coverage)
print(f"Shape of all_coverage array: {result_windowed_struct.all_coverage.shape}")

# --- Save Inversion Outputs ---
# Define output directory for these specific results.
# IMPORTANT: Hardcoded absolute path.
output_dir_structure_wc = "C:/Users/HChen8/Documents/GitHub/PyHydroGeophysX/examples/results/Structure_WC"
os.makedirs(output_dir_structure_wc, exist_ok=True) # Ensure directory exists.

# Save the inverted resistivity models.
# `result.mesh.cellMarkers()` might be used if only a subset of model related to specific markers is needed.
# Here, it seems to be indexing the model array with all cell markers, which might not be standard
# unless `cellMarkers` is a boolean array or specific indices.
# Assuming `result.mesh.cellMarkers()` refers to the markers of the input `mesh_with_interface`
# and the `final_models` are already for these cells.
# If `final_models` are defined on the full `mesh_with_interface` (which they should be),
# then direct saving is appropriate.
# The indexing `result.final_models[result.mesh.cellMarkers(),:]` seems unusual.
# It should likely be just `result.final_models` if it's already for the correct cells,
# or if it's for a larger mesh, then `result.final_models[result.mesh.coreCells(), :]` or similar.
# Given `mesh_with_interface` was used, `result.mesh` should be `mesh_with_interface`.
# If `result.mesh.cellMarkers()` is intended as a mask for valid cells, ensure it's boolean or indices.
# For now, assuming `result.final_models` is the complete set of cell values for the mesh.
np.save(os.path.join(output_dir_structure_wc, "resmodel.npy"), result_windowed_struct.final_models)
# Save coverage values (ray density). Similar indexing concern for `all_coverage`.
np.save(os.path.join(output_dir_structure_wc, "all_coverage.npy"), result_windowed_struct.all_coverage)
# Save the mesh used for the inversion (this is the structurally constrained mesh).
result_windowed_struct.mesh.save(os.path.join(output_dir_structure_wc, "mesh_res.bms"))
print(f"Inversion results (models, coverage, mesh) saved to: {output_dir_structure_wc}")

# %%
# --- Visualize Windowed Time-Lapse Inversion Results ---
# Import colormap and set Matplotlib styling.
from palettable.lightbartlein.diverging import BlueDarkRed18_18
import matplotlib.pyplot as plt # Already imported
import numpy as np # Already imported
import matplotlib.pylab as pylab # Already imported

# Apply custom Matplotlib parameters for plot appearance.
params_tl_plot = {'legend.fontsize': 13, # Renamed params dict
                  'axes.labelsize': 13,
                  'axes.titlesize':13,
                  'xtick.labelsize':13,
                  'ytick.labelsize':13}
pylab.rcParams.update(params_tl_plot)
plt.rcParams["font.family"] = "Arial"

# Assign colormap for resistivity plots.
fixed_cmap_tl = BlueDarkRed18_18.mpl_colormap # Renamed

# Create a figure to display all 12 inverted resistivity models.
fig_tl_results, axes_tl_results = plt.subplots(3, 4, figsize=[16, 6]) # Renamed fig and axs
# `subplots_adjust` can fine-tune spacing if `tight_layout` isn't perfect.
plt.subplots_adjust(wspace=0.05, hspace=0.05) # Adjust horizontal and vertical spacing.

# Iterate through each timestep and plot its corresponding inverted resistivity model.
for i in range(12): # Assuming 12 timesteps.
    row, col = i // 4, i % 4 # Calculate subplot row and column index.
    ax = fig_tl_results.add_subplot(3, 4, i + 1) # Add subplot to the figure.
    
    # Determine if Y-axis label ("Elevation (m)") should be shown (only for leftmost subplots).
    ylabel_text_tl = "Elevation (m)" if col == 0 else None # Renamed
    
    # Determine if the colorbar label should be shown (e.g., only for one specific subplot).
    # Here, it's shown for the 8th plot (index 7: middle row, rightmost).
    resistivity_cbar_label_tl = ' Resistivity ($\Omega$m)' if (i == 7) else None # Renamed. Corrected label text.
    
    # Control visibility of X and Y ticks for a cleaner grid of plots.
    if col != 0: # If not the first column, hide Y-tick labels.
        ax.set_yticklabels([])
    if row != 2:  # If not the bottom row, hide X-tick labels.
        ax.set_xticklabels([])
    else: # For bottom row subplots, set the X-axis label.
        ax.set_xlabel("Distance (m)")
    
    # Plot the resistivity model for the current timestep `i`.
    # `result_windowed_struct.mesh` is the structurally constrained mesh.
    # `result_windowed_struct.final_models[:,i]` is the inverted model for this timestep.
    # `result_windowed_struct.all_coverage[i]` is used for masking low-coverage areas.
    # The indexing `[result_windowed_struct.mesh.cellMarkers()]` on both model and coverage
    # is unusual and likely incorrect if `cellMarkers()` returns region numbers rather than a boolean mask
    # or direct indices into the model/coverage array that are already cell-based.
    # Assuming `final_models` and `all_coverage` are already per-cell arrays for `result.mesh`.
    # If `result.mesh.cellMarkers()` is intended to select a subset of cells (e.g. only one region),
    # then the mesh passed to `pg.show` should also be that subset, or `pg.show` needs to handle it.
    # For now, assuming direct plotting of the full model on the full mesh is intended.
    # If `final_models` columns are already aligned with `mesh.cells()`, no further indexing by markers is needed for `data`.
    model_to_plot = result_windowed_struct.final_models[:,i]
    coverage_to_plot = result_windowed_struct.all_coverage[i,:] > -1.2 if result_windowed_struct.all_coverage is not None and i < result_windowed_struct.all_coverage.shape[0] else None

    _, cbar = pg.show(result_windowed_struct.mesh, # The mesh
                      model_to_plot,                # Data for this timestep
                      pad=0.3, orientation="vertical",
                      cMap=fixed_cmap_tl, cMin=100, cMax=3000, logScale=False,
                      ylabel=ylabel_text_tl, label=resistivity_cbar_label_tl, ax=ax,
                      coverage=coverage_to_plot) # Masking based on coverage.

    # Add markers for specific points of interest on the first timestep's plot (i=0).
    if i ==0:
        ax.plot([40],[1607],'*',c='k', markersize=8) # Example point 1
        ax.plot([80],[1621],'*',c='k', markersize=8) # Example point 2
        ax.plot([30],[1604],'*',c='k', markersize=8) # Example point 3
        ax.plot([65],[1608],'*',c='k', markersize=8) # Example point 4
        
    # Remove individual colorbars from subplots where the label is not shown (all but i=7).
    if i != 7:
        if cbar: cbar.remove() # Check if cbar object exists before removing.

fig_tl_results.tight_layout() # Adjust overall layout of subplots.
plt.suptitle("Structurally Constrained Windowed Time-Lapse ERT Inversion", fontsize=16, y=1.02) # Add overall title.
plt.show() # Display the plot. Output: Matplotlib figure with 12 subplots.


# %%
# The script ends here. Subsequent cells for water content conversion and uncertainty
# analysis using ERTtoWC would typically follow, using `result_windowed_struct.final_models`
# and `result_windowed_struct.mesh`.
# Example (conceptual, from problem description, assuming ERTtoWC is defined elsewhere):
# from PyHydroGeophysX.postprocessing.ERT_to_WC import ERTtoWC
# ert_to_wc_converter = ERTtoWC(
#     resistivity_models=result_windowed_struct.final_models,
#     mesh=result_window_struct.mesh,
#     # ... other necessary parameters like porosity, petrophysical params per layer ...
# )
# wc_results_mean, wc_results_std = ert_to_wc_converter.run_monte_carlo(samples=100)
# ert_to_wc_converter.plot_time_series(locations=[...], output_dir=output_dir_structure_wc)
# print("Water content conversion and uncertainty analysis would be performed in subsequent (currently commented) steps.")
# End of Example 7.
