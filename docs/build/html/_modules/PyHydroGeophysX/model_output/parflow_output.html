<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyHydroGeophysX.model_output.parflow_output &mdash; PyHydroGeophysX Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="canonical" href="https://geohang.github.io/PyHydroGeophysX/_modules/PyHydroGeophysX/model_output/parflow_output.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=2389946f"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PyHydroGeophysX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples Gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyHydroGeophysX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">PyHydroGeophysX.model_output.parflow_output</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PyHydroGeophysX.model_output.parflow_output</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for processing ParFlow model outputs.</span>

<span class="sd">This module provides classes to handle specific types of ParFlow outputs,</span>
<span class="sd">such as saturation and porosity, by reading ParFlow Binary Files (PFB).</span>
<span class="sd">It relies on the `parflow` Python package for PFB reading capabilities.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span> <span class="c1"># Dict and Union not directly used here, but Any is.</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">HydroModelOutput</span> <span class="c1"># Assuming base.py is in the same directory or package</span>


<div class="viewcode-block" id="ParflowOutput"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowOutput">[docs]</a><span class="k">class</span> <span class="nc">ParflowOutput</span><span class="p">(</span><span class="n">HydroModelOutput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for processing ParFlow model outputs.</span>

<span class="sd">    This class handles common ParFlow output functionalities, such as</span>
<span class="sd">    identifying available timesteps and interfacing with the `parflow`</span>
<span class="sd">    Python package for reading PFB files. Specific data types (like</span>
<span class="sd">    saturation, porosity) should be handled by subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ParflowOutput.__init__"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowOutput.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">run_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ParFlow output processor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_directory (str): Path to the ParFlow simulation output directory.</span>
<span class="sd">            run_name (str): The base name of the ParFlow run (e.g., &#39;my_run&#39; if</span>
<span class="sd">                            output files are like &#39;my_run.out.satur.00001.pfb&#39;).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ImportError: If the `parflow` Python package is not installed.</span>
<span class="sd">            FileNotFoundError: If `model_directory` does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model_directory</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model directory not found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">run_name</span> <span class="o">=</span> <span class="n">run_name</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Dynamically import parflow and its PFB reading tool.</span>
            <span class="c1"># This makes `parflow` an optional dependency if ParflowOutput classes are not used.</span>
            <span class="kn">import</span> <span class="nn">parflow.tools.io</span> <span class="k">as</span> <span class="nn">pftools</span> <span class="c1"># Changed from `import parflow`</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parflow_available</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_pfb</span> <span class="o">=</span> <span class="n">pftools</span><span class="o">.</span><span class="n">read_pfb</span> <span class="c1"># Assign the function directly</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parflow_available</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Critical dependency for this class to function.</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;The &#39;parflow&#39; Python package is required to process ParFlow outputs. &quot;</span>
                              <span class="s2">&quot;Please install it (e.g., &#39;pip install parflow&#39;).&quot;</span><span class="p">)</span>
        
        <span class="c1"># Discover available timesteps upon initialization.</span>
        <span class="c1"># Potential Issue: If new output files are written after initialization,</span>
        <span class="c1"># this list won&#39;t update unless refreshed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_available_timesteps</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: No ParFlow output timesteps found for run &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">&#39; in &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                  <span class="s2">&quot;Check run_name and file patterns (e.g., *.out.satur.*.pfb).&quot;</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_get_available_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scans the model directory to find available ParFlow output timesteps.</span>

<span class="sd">        It looks for files matching common ParFlow output patterns (e.g., for</span>
<span class="sd">        saturation or pressure) and extracts the timestep numbers from their names.</span>
<span class="sd">        Timestep numbers are assumed to be integers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: A sorted list of unique integer timestep numbers found.</span>
<span class="sd">                       Returns an empty list if no matching files are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timesteps_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Use a set to automatically handle duplicates if patterns overlap</span>

        <span class="c1"># Common ParFlow output file patterns.</span>
        <span class="c1"># Files are typically named &lt;run_name&gt;.out.&lt;variable_name&gt;.&lt;timestep_number&gt;.pfb</span>
        <span class="c1"># The timestep number is often zero-padded (e.g., 00001, 00002, ...).</span>
        <span class="c1"># This pattern tries to capture that.</span>
        <span class="c1"># Example: my_run.out.satur.00001.pfb -&gt; timestep 1</span>
        <span class="c1"># Example: my_run.out.press.00010.pfb -&gt; timestep 10</span>

        <span class="c1"># Define patterns to search for. Prioritize saturation files, then pressure if no saturation found.</span>
        <span class="c1"># This is heuristic; ParFlow output naming can be configured.</span>
        <span class="n">patterns_to_check</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.satur.&quot;</span><span class="p">,</span> <span class="c1"># Saturation files</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.press.&quot;</span>  <span class="c1"># Pressure files (as fallback for timestep discovery)</span>
        <span class="p">]</span>

        <span class="n">found_primary_pattern</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">pattern_prefix</span> <span class="ow">in</span> <span class="n">patterns_to_check</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">found_primary_pattern</span> <span class="ow">and</span> <span class="n">pattern_prefix</span> <span class="o">==</span> <span class="n">patterns_to_check</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># If already found satur, skip press for discovery</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">pattern_prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filename</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pfb&quot;</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Extract the part after the prefix: e.g., &quot;00001.pfb&quot;</span>
                        <span class="n">timestep_str_part</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern_prefix</span><span class="p">):]</span>
                        <span class="c1"># Remove &quot;.pfb&quot; and any other potential suffixes if complex naming (e.g. .clm.).</span>
                        <span class="c1"># Simplest is to split by &#39;.&#39; and take the first part.</span>
                        <span class="n">timestep_str</span> <span class="o">=</span> <span class="n">timestep_str_part</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">timestep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timestep_str</span><span class="p">)</span> <span class="c1"># Convert to integer</span>
                        <span class="n">timesteps_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pattern_prefix</span> <span class="o">==</span> <span class="n">patterns_to_check</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># Found saturation files</span>
                            <span class="n">found_primary_pattern</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># If int conversion fails (e.g., filename &quot;my_run.out.satur.final.pfb&quot;)</span>
                        <span class="c1"># print(f&quot;Warning: Could not parse timestep from filename: {filename}&quot;)</span>
                        <span class="k">continue</span> <span class="c1"># Skip this file</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span> <span class="c1"># If split by &#39;.&#39; results in empty list (shouldn&#39;t happen with .pfb)</span>
                        <span class="c1"># print(f&quot;Warning: Could not parse timestep due to unexpected filename structure: {filename}&quot;)</span>
                        <span class="k">continue</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">timesteps_set</span><span class="p">))</span> <span class="c1"># Return sorted list of unique timesteps</span>
    
<div class="viewcode-block" id="ParflowOutput.get_pfb_dimensions"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowOutput.get_pfb_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_pfb_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pfb_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a PFB file and returns its data dimensions (nz, ny, nx).</span>

<span class="sd">        Args:</span>
<span class="sd">            pfb_file_path (str): The full path to the PFB file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[int, int, int]: The dimensions of the data in the PFB file,</span>
<span class="sd">                                  typically in (nz, ny, nx) order for ParFlow.</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: If the `pfb_file_path` does not exist.</span>
<span class="sd">            Exception: If `self.read_pfb` (from parflow.tools.io) fails to read the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pfb_file_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PFB file not found: </span><span class="si">{</span><span class="n">pfb_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># self.read_pfb is `parflow.tools.io.read_pfb`</span>
        <span class="c1"># This function typically returns a NumPy array.</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pfb</span><span class="p">(</span><span class="n">pfb_file_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Should not happen if read_pfb works as expected.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected NumPy array from read_pfb, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="si">}</span><span class="s2"> for file </span><span class="si">{</span><span class="n">pfb_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># ParFlow PFB files usually store data in (nz, ny, nx) order.</span>
        <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Potential Issue: If data is not 3D (e.g., 2D slice, or 1D output).</span>
            <span class="c1"># This method assumes 3D output. Adapt if other dimensionalities are common.</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: PFB file &#39;</span><span class="si">{</span><span class="n">pfb_file_path</span><span class="si">}</span><span class="s2">&#39; data is not 3-dimensional (shape: </span><span class="si">{</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">). Assuming (nz=1, ny=1, nx=shape[0]) or similar if 1D.&quot;</span><span class="p">)</span>
            <span class="c1"># Handle common cases for non-3D data to still return a 3-tuple.</span>
            <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># If &gt; 3D, this is unexpected for standard ParFlow scalar outputs.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PFB file &#39;</span><span class="si">{</span><span class="n">pfb_file_path</span><span class="si">}</span><span class="s2">&#39; has unsupported data dimensionality: </span><span class="si">{</span><span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Returns (nz, ny, nx)</span></div></div>


<div class="viewcode-block" id="ParflowSaturation"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowSaturation">[docs]</a><span class="k">class</span> <span class="nc">ParflowSaturation</span><span class="p">(</span><span class="n">ParflowOutput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes saturation data from ParFlow simulations (.out.satur.*.pfb files).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ParflowSaturation.__init__"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowSaturation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">run_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ParFlow saturation processor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_directory (str): Path to the ParFlow simulation output directory.</span>
<span class="sd">            run_name (str): The base name of the ParFlow run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">run_name</span><span class="p">)</span></div>
        <span class="c1"># Additional check: Ensure saturation files were indeed the source of timesteps if specific.</span>
        <span class="c1"># For now, _get_available_timesteps is generic.</span>
    
<div class="viewcode-block" id="ParflowSaturation.load_timestep"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowSaturation.load_timestep">[docs]</a>    <span class="k">def</span> <span class="nf">load_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load saturation data for a specific, zero-based timestep index.</span>

<span class="sd">        Args:</span>
<span class="sd">            timestep_idx (int): The zero-based index of the timestep to load from the</span>
<span class="sd">                                list of available timesteps discovered during initialization.</span>
<span class="sd">            **kwargs (Any): Additional keyword arguments (not used by this method).</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 3D NumPy array of saturation values (nz, ny, nx).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If no timesteps are available or if `timestep_idx` is out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ParFlow timesteps were found. Cannot load saturation data.&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">timestep_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Timestep index </span><span class="si">{</span><span class="n">timestep_idx</span><span class="si">}</span><span class="s2"> is out of range. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Available indices: 0 to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">actual_timestep_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">[</span><span class="n">timestep_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="n">actual_timestep_number</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal helper to load saturation data for a given ParFlow timestep number.</span>

<span class="sd">        Args:</span>
<span class="sd">            timestep_number (int): The actual timestep number as found in the ParFlow</span>
<span class="sd">                                   output filename (e.g., 1 for *.00001.pfb).</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3D array of saturation values (nz, ny, nx).</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: If the specific saturation PFB file cannot be found.</span>
<span class="sd">            ValueError: If there&#39;s an error reading or processing the PFB file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct the expected saturation PFB filename.</span>
        <span class="c1"># ParFlow typically zero-pads timestep numbers to 5 digits.</span>
        <span class="c1"># Potential Issue: Padding might vary based on ParFlow version or settings.</span>
        <span class="c1"># The original code tries 5-digit padding first, then without if not found.</span>
        <span class="c1"># This seems like a reasonable fallback.</span>
        <span class="n">satur_filename_padded</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.satur.</span><span class="si">{</span><span class="n">timestep_number</span><span class="si">:</span><span class="s2">05d</span><span class="si">}</span><span class="s2">.pfb&quot;</span>
        <span class="n">satur_file_path_padded</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">satur_filename_padded</span><span class="p">)</span>

        <span class="n">satur_filename_unpadded</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.satur.</span><span class="si">{</span><span class="n">timestep_number</span><span class="si">}</span><span class="s2">.pfb&quot;</span>
        <span class="n">satur_file_path_unpadded</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">satur_filename_unpadded</span><span class="p">)</span>

        <span class="n">chosen_path</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">satur_file_path_padded</span><span class="p">):</span>
            <span class="n">chosen_path</span> <span class="o">=</span> <span class="n">satur_file_path_padded</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">satur_file_path_unpadded</span><span class="p">):</span>
            <span class="n">chosen_path</span> <span class="o">=</span> <span class="n">satur_file_path_unpadded</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Saturation file for timestep </span><span class="si">{</span><span class="n">timestep_number</span><span class="si">}</span><span class="s2"> not found. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Checked: &#39;</span><span class="si">{</span><span class="n">satur_file_path_padded</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">satur_file_path_unpadded</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">saturation_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pfb</span><span class="p">(</span><span class="n">chosen_path</span><span class="p">)</span> <span class="c1"># Use the instance&#39;s PFB reader</span>
            
            <span class="c1"># ParFlow uses large negative numbers (e.g., -1.0E+39, -2.0E+39) to denote no-data or inactive cells.</span>
            <span class="c1"># Replace these with NaN for more standard handling in NumPy/plotting.</span>
            <span class="c1"># The threshold -1e38 is from the original code.</span>
            <span class="c1"># Potential Improvement: This threshold might need to be more robust or configurable</span>
            <span class="c1"># if ParFlow&#39;s no-data value representation varies.</span>
            <span class="n">saturation_data</span><span class="p">[</span><span class="n">saturation_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e38</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
            <span class="k">return</span> <span class="n">saturation_data</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c1"># Catch errors from read_pfb or subsequent numpy operations</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading or processing saturation data from &#39;</span><span class="si">{</span><span class="n">chosen_path</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="ParflowSaturation.load_time_range"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowSaturation.load_time_range">[docs]</a>    <span class="k">def</span> <span class="nf">load_time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load saturation data for a specified range of zero-based timestep indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_idx (int, optional): Starting zero-based timestep index. Defaults to 0.</span>
<span class="sd">            end_idx (Optional[int], optional): Ending zero-based timestep index (exclusive).</span>
<span class="sd">                                               If None, loads up to the last available timestep.</span>
<span class="sd">                                               Defaults to None.</span>
<span class="sd">            **kwargs (Any): Additional keyword arguments (not used).</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 4D NumPy array of saturation values (num_timesteps, nz, ny, nx).</span>
<span class="sd">                        Returns an empty 4D array if the range is invalid or no data is found.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If no timesteps are available, or if the specified range is invalid</span>
<span class="sd">                        (e.g., `start_idx` out of bounds, `end_idx` &lt;= `start_idx` leading to empty range).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
            <span class="c1"># This check is also in load_timestep, but good for direct calls to load_time_range.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ParFlow timesteps available. Cannot load saturation data.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Validate and adjust start_idx and end_idx</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)):</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_idx </span><span class="si">{</span><span class="n">start_idx</span><span class="si">}</span><span class="s2"> is out of range for available timesteps (0 to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)</span> <span class="c1"># Go up to the last available timestep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">end_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="c1"># Interpret negative end_idx relative to end, like list slicing</span>
                <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_idx</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Positive or zero</span>
                <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">actual_end_idx</span> <span class="o">&lt;=</span> <span class="n">start_idx</span><span class="p">:</span>
            <span class="c1"># print(f&quot;Warning: Requested time range (start_idx={start_idx}, end_idx={end_idx} -&gt; actual_end_idx={actual_end_idx}) is empty or invalid.&quot;)</span>
            <span class="c1"># Return empty array with expected dimensions if possible (need to know spatial dims first)</span>
            <span class="c1"># For now, let timesteps_to_load handle this; if it&#39;s empty, ValueError will be raised.</span>
            <span class="c1"># Or, get spatial dims from first available timestep if start_idx is valid.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
                 <span class="n">first_data_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                 <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">first_data_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="c1"># 0 timesteps, but correct spatial shape</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Should not happen if initial check passed.</span>
                 <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># Fallback if no timesteps at all.</span>


        <span class="c1"># Get the list of actual ParFlow timestep numbers to load based on indices</span>
        <span class="n">timesteps_to_load_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">actual_end_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">timesteps_to_load_numbers</span><span class="p">:</span>
            <span class="c1"># This case should ideally be caught by actual_end_idx &lt;= start_idx logic.</span>
            <span class="c1"># However, if slicing results in empty list for other reasons:</span>
            <span class="c1"># print(f&quot;Warning: No timesteps selected for index range [{start_idx}, {actual_end_idx}).&quot;)</span>
            <span class="c1"># Determine spatial shape from the first available timestep for empty array structure</span>
            <span class="n">first_data_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">first_data_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># Load the first timestep in the range to determine spatial dimensions (nz, ny, nx)</span>
        <span class="c1"># This assumes all PFB files for this variable have consistent dimensions.</span>
        <span class="n">first_timestep_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="n">timesteps_to_load_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">first_timestep_data</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># Initialize a 4D NumPy array to store all loaded saturation data</span>
        <span class="c1"># Shape: (number_of_timesteps_in_range, nz, ny, nx)</span>
        <span class="n">all_saturation_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">timesteps_to_load_numbers</span><span class="p">),</span> <span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
        
        <span class="n">all_saturation_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_timestep_data</span> <span class="c1"># Store the already loaded first timestep</span>
        
        <span class="c1"># Load the remaining timesteps in the range</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">timestep_num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">timesteps_to_load_numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># Start from 1 as 0 is filled</span>
            <span class="n">all_saturation_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_saturation_for_timestep_num</span><span class="p">(</span><span class="n">timestep_num</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">all_saturation_data</span></div>
    
<div class="viewcode-block" id="ParflowSaturation.get_timestep_info"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowSaturation.get_timestep_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestep_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides information about available ParFlow timesteps.</span>

<span class="sd">        For ParFlow, the timestep number from the filename often directly corresponds</span>
<span class="sd">        to the simulation time (e.g., if output is every 1 hour, timestep 24 is 24 hours).</span>
<span class="sd">        This method returns a list of tuples: (timestep_number, simulation_time).</span>
<span class="sd">        Currently, simulation_time is simply cast from timestep_number.</span>
<span class="sd">        More accurate time mapping would require parsing ParFlow timing files if complex.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[int, float]]: A list where each tuple is (timestep_number, time_value).</span>
<span class="sd">                                     Time_value is float representation of timestep_number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assumes timestep number can be directly used as a proxy for simulation time.</span>
        <span class="c1"># For more complex timing, ParFlow&#39;s run script or timing output files (.tcl, .timing)</span>
        <span class="c1"># would need to be parsed, which is beyond the scope of simple PFB reading.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">ts_num</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">ts_num</span><span class="p">))</span> <span class="k">for</span> <span class="n">ts_num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="ParflowPorosity"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity">[docs]</a><span class="k">class</span> <span class="nc">ParflowPorosity</span><span class="p">(</span><span class="n">ParflowOutput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes porosity data from ParFlow simulations.</span>
<span class="sd">    Porosity in ParFlow is typically static (time-invariant) and stored in a</span>
<span class="sd">    single PFB file (e.g., &lt;run_name&gt;.out.porosity.pfb or similar).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ParflowPorosity.__init__"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">run_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ParFlow porosity processor.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_directory (str): Path to the ParFlow simulation output directory.</span>
<span class="sd">            run_name (str): The base name of the ParFlow run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call super().__init__ but note that _get_available_timesteps might not be</span>
        <span class="c1"># relevant if porosity is truly static and doesn&#39;t have timed output files.</span>
        <span class="c1"># However, the base class structure expects it.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">run_name</span><span class="p">)</span></div>
        <span class="c1"># Porosity doesn&#39;t usually have multiple timesteps, so self.available_timesteps</span>
        <span class="c1"># from base class (derived from saturation/pressure files) might be misleading if used here.</span>
    
<div class="viewcode-block" id="ParflowPorosity.load_porosity"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.load_porosity">[docs]</a>    <span class="k">def</span> <span class="nf">load_porosity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the static porosity data from the ParFlow model.</span>

<span class="sd">        It searches for common ParFlow porosity filename patterns within the</span>
<span class="sd">        model directory.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 3D NumPy array of porosity values (nz, ny, nx).</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: If no standard porosity PFB file can be found.</span>
<span class="sd">            ValueError: If there&#39;s an error reading or processing the PFB file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Common filename patterns for ParFlow porosity files.</span>
        <span class="c1"># Order can matter if multiple potentially exist, though usually only one is standard.</span>
        <span class="n">porosity_filename_candidates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.porosity.pfb&quot;</span><span class="p">,</span> <span class="c1"># Common for outputs</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.porosity.pfb&quot;</span><span class="p">,</span>     <span class="c1"># Sometimes used if input or static field</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.pf.porosity.pfb&quot;</span><span class="p">,</span>  <span class="c1"># Alternative prefixing</span>
            <span class="c1"># Add non-pfb extensions if ParFlow might write them as plain binary without .pfb</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.porosity&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.pf.porosity&quot;</span>
        <span class="p">]</span>
        
        <span class="n">found_file_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">porosity_filename_candidates</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
                <span class="n">found_file_path</span> <span class="o">=</span> <span class="n">file_path</span>
                <span class="k">break</span> <span class="c1"># Found a candidate</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_file_path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not find a porosity file for run &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">&#39; in directory &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Checked patterns like &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.porosity.pfb&#39;.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">porosity_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pfb</span><span class="p">(</span><span class="n">found_file_path</span><span class="p">)</span>
            <span class="c1"># Handle ParFlow&#39;s no-data values, similar to saturation.</span>
            <span class="n">porosity_data</span><span class="p">[</span><span class="n">porosity_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e38</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># Potential Issue: Porosity should ideally be between 0 and 1.</span>
            <span class="c1"># Add validation or clipping if ParFlow might output other values for active cells.</span>
            <span class="c1"># e.g., np.clip(porosity_data, 0.0, 1.0) after NaNs are set.</span>
            <span class="c1"># However, if -1e38 are truly no-data, they should remain NaN, not clipped to 0.</span>
            <span class="k">return</span> <span class="n">porosity_data</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading or processing porosity data from &#39;</span><span class="si">{</span><span class="n">found_file_path</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ParflowPorosity.load_mask"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.load_mask">[docs]</a>    <span class="k">def</span> <span class="nf">load_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="c1"># Original name was load_porosity, but seems to load mask</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the domain mask data from a ParFlow model.</span>
<span class="sd">        The mask file (.out.mask.pfb) indicates active (1) and inactive (0) cells.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 3D NumPy array representing the domain mask (nz, ny, nx).</span>
<span class="sd">                        Values are typically 0 or 1.</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: If no standard mask PFB file can be found.</span>
<span class="sd">            ValueError: If there&#39;s an error reading or processing the PFB file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Common filename patterns for ParFlow mask files.</span>
        <span class="n">mask_filename_candidates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.mask.pfb&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.mask.pfb&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.pf.mask.pfb&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.mask&quot;</span><span class="p">,</span> <span class="c1"># Fallback for non-.pfb extension</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.pf.mask&quot;</span>
        <span class="p">]</span>
        
        <span class="n">found_file_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">mask_filename_candidates</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
                <span class="n">found_file_path</span> <span class="o">=</span> <span class="n">file_path</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_file_path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not find a mask file for run &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">&#39; in directory &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Checked patterns like &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">run_name</span><span class="si">}</span><span class="s2">.out.mask.pfb&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mask_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pfb</span><span class="p">(</span><span class="n">found_file_path</span><span class="p">)</span>
            <span class="c1"># ParFlow mask values are typically 0 (inactive) or 1 (active).</span>
            <span class="c1"># No-data value handling might not be strictly necessary if format is clean 0s and 1s.</span>
            <span class="c1"># However, applying it consistently with other PFB reads doesn&#39;t hurt.</span>
            <span class="n">mask_data</span><span class="p">[</span><span class="n">mask_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e38</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Or set to 0 if NaN is not desired for mask</span>
            <span class="k">return</span> <span class="n">mask_data</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading or processing mask data from &#39;</span><span class="si">{</span><span class="n">found_file_path</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParflowPorosity.load_timestep"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.load_timestep">[docs]</a>    <span class="k">def</span> <span class="nf">load_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load porosity data. For ParFlow, porosity is typically time-invariant.</span>
<span class="sd">        This method returns the static porosity array, ignoring `timestep_idx`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            timestep_idx (int): Index of the timestep (ignored, as porosity is static).</span>
<span class="sd">            **kwargs (Any): Additional keyword arguments (not used).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 3D NumPy array of porosity values (nz, ny, nx).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Porosity is static, so any timestep_idx request returns the same data.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_porosity</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="ParflowPorosity.load_time_range"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.load_time_range">[docs]</a>    <span class="k">def</span> <span class="nf">load_time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load porosity data for a conceptual range of timesteps.</span>
<span class="sd">        Since porosity is time-invariant, this method returns a 4D array where</span>
<span class="sd">        the static 3D porosity data is repeated along the time axis.</span>

<span class="sd">        The number of repetitions along the time axis (`nt`) is determined by</span>
<span class="sd">        the length of `self.available_timesteps` (discovered from saturation/pressure files)</span>
<span class="sd">        if `end_idx` is None, or by `min(end_idx - start_idx, len(available_timesteps))`.</span>
<span class="sd">        A minimum of 1 repetition is ensured if any timesteps are notionally available.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            start_idx (int, optional): Starting timestep index (used to determine `nt`). Defaults to 0.</span>
<span class="sd">            end_idx (Optional[int], optional): Ending timestep index (exclusive, used for `nt`).</span>
<span class="sd">                                               Defaults to None (use all available timesteps).</span>
<span class="sd">            **kwargs (Any): Additional keyword arguments (not used).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A 4D NumPy array of porosity values (nt, nz, ny, nx).</span>
<span class="sd">                        All slices along the time dimension are identical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">porosity_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_porosity</span><span class="p">()</span> <span class="c1"># (nz, ny, nx)</span>

        <span class="n">num_timesteps_in_output</span><span class="p">:</span> <span class="nb">int</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span> <span class="c1"># No timed output files found by base class</span>
            <span class="n">num_timesteps_in_output</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Assume at least one &quot;time&quot; for static data</span>
        <span class="k">elif</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If end_idx is not specified, use timesteps from start_idx to end of available list</span>
            <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Ensure start_idx is not negative</span>
            <span class="n">num_timesteps_in_output</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Adjust end_idx if it&#39;s negative or too large</span>
            <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="n">end_idx</span>
            <span class="k">if</span> <span class="n">end_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_idx</span>
            <span class="n">actual_end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">actual_end_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">))</span>

            <span class="c1"># Ensure start_idx is valid</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">)):</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">num_timesteps_in_output</span> <span class="o">=</span> <span class="n">actual_end_idx</span> <span class="o">-</span> <span class="n">start_idx</span>
        
        <span class="n">num_timesteps_in_output</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_timesteps_in_output</span><span class="p">)</span> <span class="c1"># Ensure not negative</span>
        <span class="k">if</span> <span class="n">num_timesteps_in_output</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span> <span class="c1"># If range was invalid but timesteps exist</span>
            <span class="n">num_timesteps_in_output</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Default to 1 repetition if a valid range wasn&#39;t specified but data exists</span>
        <span class="k">elif</span> <span class="n">num_timesteps_in_output</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span> <span class="c1"># No range, no data</span>
             <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">porosity_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>


        <span class="c1"># Add a new time axis and tile the 3D porosity array</span>
        <span class="c1"># Shape becomes (1, nz, ny, nx), then tiled to (num_timesteps_in_output, nz, ny, nx)</span>
        <span class="n">porosity_4d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">porosity_3d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="n">num_timesteps_in_output</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">porosity_4d</span></div>
    
<div class="viewcode-block" id="ParflowPorosity.get_timestep_info"><a class="viewcode-back" href="../../../api/PyHydroGeophysX.model_output.html#PyHydroGeophysX.model_output.parflow_output.ParflowPorosity.get_timestep_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestep_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns timestep information, typically based on other ParFlow outputs</span>
<span class="sd">        (like saturation) as porosity itself is static.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[int, float]]: A list of (timestep_number, time_value) tuples,</span>
<span class="sd">                                     derived from `self.available_timesteps`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Porosity is static, but to align with the interface, return timestep info</span>
        <span class="c1"># based on what other timed outputs (e.g., saturation) suggest.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">:</span>
            <span class="c1"># If no other timed outputs were found to define timesteps,</span>
            <span class="c1"># provide a single dummy entry for the static porosity data.</span>
            <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span> <span class="c1"># (timestep_number, conceptual_time)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">ts_num</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">ts_num</span><span class="p">))</span> <span class="k">for</span> <span class="n">ts_num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_timesteps</span><span class="p">]</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Hang Chen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>